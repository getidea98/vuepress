# è¯»å†™é”

è¯»å†™é”ä¾èµ–AQSæ¥å®ç°åŒæ­¥åŠŸèƒ½ï¼Œè€Œè¯»å†™çŠ¶æ€å°±æ˜¯AQSçš„`state`ã€‚

ä¸€ä¸ªæ•´å½¢å˜é‡åŒæ—¶ç»´æŠ¤ç€è¯»å†™çŠ¶æ€ï¼Œå¿…ç„¶éœ€è¦å°†å…¶â€œæŒ‰ä½åˆ‡å‰²ä½¿ç”¨â€

![è¯»å†™é”çŠ¶æ€çš„åˆ’åˆ†æ–¹å¼](/imgs/TheArtOfJavaConcurrentProgramming/è¯»å†™é”1.png)

è¯»å†™é”çŠ¶æ€çš„åˆ’åˆ†æ–¹å¼

çŠ¶æ€çš„åˆ’åˆ†èƒ½å¾—å‡ºä¸€ä¸ªæ¨è®ºï¼šé«˜ä½ä¸ç­‰äº0æ—¶ï¼Œå½“å†™çŠ¶æ€ï¼ˆS&0x0000FFFFï¼‰ç­‰äº0æ—¶ï¼Œåˆ™è¯»çŠ¶æ€å¤§äº0ï¼Œå³è¯»é”å·²è¢«è·å–ã€‚

## **å†™é”çš„è·å–ä¸é‡Šæ”¾**

é¦–å…ˆåˆ¤æ–­çŠ¶æ€ä¸ç­‰äº0ï¼Œåˆ™è§†ä¸ºå½“å‰é”è¢«è·å–äº†ã€‚ä¸çŸ¥é“æ˜¯è¯»é”è·å–è¿˜æ˜¯å†™é”è¢«è·å–ã€‚

éšååˆ¤æ–­å†™é”æ˜¯ä¸æ˜¯0ï¼ˆ0ä»£è¡¨å†™é”è·å–ï¼Œä¹Ÿå°±æ˜¯å½“å‰çš„è¯»é”è¢«è·å–äº†ã€‚ï¼‰ï¼Œå¦‚æœå†™é”è¢«è·å–ï¼Œå¹¶ä¸”ç‹¬å çš„çº¿ç¨‹æ˜¯è‡ªèº«ï¼Œåˆ™è§†ä¸ºè‡ªå·±å†æ¬¡è·å–åˆ°è¯»é”ã€‚

é™¤æ­¤ä¹‹å¤–ï¼Œè§†ä¸ºè·å–é”å¤±è´¥éƒ½æ˜¯è·å–é”å¤±è´¥ã€‚

<aside>
ğŸ’¡ æœ‰ä¸¤ä¸ªæ¡ä»¶ï¼Œå†™é”æ‰èƒ½è·å–åŒæ­¥çŠ¶æ€ï¼š
1. åŒæ­¥çŠ¶æ€æ˜¯0ï¼Œè§†ä¸ºæ²¡æœ‰ä»»ä½•çº¿ç¨‹æŒæœ‰é”ã€‚
2.åŒæ­¥çŠ¶æ€ä¸æ˜¯0ï¼ŒåŒæ—¶stateä½ä½ä¸æ˜¯0ï¼ˆè¢«è·å–å†™é”ï¼‰ï¼Œå¹¶ä¸”æŒæœ‰é”çš„çº¿ç¨‹æ˜¯è‡ªèº«ã€‚

</aside>

```java
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w =exclusiveCount(c);
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w +exclusiveCount(acquires) >MAX_COUNT)
            throw new Error("Maximum lock count exceeded");
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
```

æ³¨æ„âš ï¸ï¼šc == 0 çš„åˆ†æ”¯ï¼Œæœ‰ä¸€ä¸ªwriterShouldBlock()ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯å…¬å¹³æˆ–éå…¬å¹³è·å–é”çš„æ ¸å¿ƒã€‚

## è¯»é”çš„è·å–ä¸é‡Šæ”¾

å¦‚æœå…¶ä»–çº¿ç¨‹å·²ç»è·å–äº†å†™é”ï¼Œåˆ™å½“å‰çº¿ç¨‹è·å–è¯» é”å¤±è´¥ï¼Œè¿›å…¥ç­‰å¾…çŠ¶æ€ã€‚å¦‚æœå½“å‰çº¿ç¨‹è·å–äº†å†™é”æˆ–è€…å†™é”æœªè¢«è·å–ï¼Œåˆ™å½“å‰çº¿ç¨‹ï¼ˆçº¿ç¨‹å®‰å…¨ï¼Œ ä¾é CASä¿è¯ï¼‰å¢åŠ è¯»çŠ¶æ€ï¼ŒæˆåŠŸè·å–è¯»é”ã€‚

```java
protected final int tryAcquireShared(int unused) {
    /*
     * Walkthrough:
     * 1. If write lock held by another thread, fail.
     * 2. Otherwise, this thread is eligible for
     *    lock wrt state, so ask if it should block
     *    because of queue policy. If not, try
     *    to grant by CASing state and updating count.
     *    Note that step does not check for reentrant
     *    acquires, which is postponed to full version
     *    to avoid having to check hold count in
     *    the more typical non-reentrant case.
     * 3. If step 2 fails either because thread
     *    apparently not eligible or CAS fails or count
     *    saturated, chain to version with full retry loop.
     */
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &&
        getExclusiveOwnerThread() != current)
        return -1;
    int r =sharedCount(c);
    if (!readerShouldBlock() &&
        r <MAX_COUNT&&
        compareAndSetState(c, c +SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid !=getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
```